# -*- coding: utf-8 -*-
"""22l-6839 AI Lab 3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AjG0zNlQ92v3SA0Lk_uBJOsQwbcVsl-E
"""

from collections import deque

def find_shortest_path(matrix):
    # Directions: Up, Down, Left, Right
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    # Initialize starting and ending positions
    start = (1, 1)
    end = (4, 4)
    # Initialize data structures for BFS
    queue = deque([(start, [start])])  # Use deque for BFS and store the path  [start] means path taken to reach start point
    visited = set()  # Track visited positions
    visited.add(start)  #as set has unordered and unnduplicates
    # BFS Loop
    while queue:    #while until queue is not empty
        current_position, path = queue.popleft()   #removes first element from queue and put into 2 variables and current one is the point to be explored and path taken to  it
        # Check if HOME is reached
        if current_position == end:
            return path
        # Explore neighboring cells (non-diagonal and not obstacles)
        for direction in directions:         #if the new direction is not dagonal
            new_position = (current_position[0] + direction[0], current_position[1] + direction[1])  #getting new pos by adding direction tuples to current pos
            # Check if the new position is within bounds and not visited
            if (0 <= new_position[0] < len(matrix) and      #checks that the row index of new pos is within bounds
                0 <= new_position[1] < len(matrix[0]) and    #checks if the col index of new pos is within bounds
                new_position not in visited and        #new pos is not already visited
                matrix[new_position[0]][new_position[1]] != 1):  # Assuming 1 represents an obstacle , new pos is not an obstacle
                queue.append((new_position, path + [new_position]))      #if it is valid then add to end of queue
                visited.add(new_position)              #marking it that it is visited
    # Return None if no path is found
    return None
# Example usage:
matrix = [
    [0, 0, 0, 0, 0],
    [0, 0, 1, 1, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 0, 0, 1],
    [0, 0, 0, 0, 0]
]
shortest_path = find_shortest_path(matrix)
print("Shortest Path:", shortest_path)

import time
from collections import deque

def state_to_tuple(state):
    """Convert a string state to a tuple representation."""
    return tuple(tuple(int(state[i + j]) for j in range(3)) for i in range(0, 9, 3))

def tuple_to_state(matrix):
    """Convert a tuple representation back to a string state."""
    return ''.join(str(num) for row in matrix for num in row)

def get_moves(matrix):
    """Generate possible moves from the given state."""
    moves = []
    row, col = next((i, j) for i, row in enumerate(matrix) for j, val in enumerate(row) if val == 0)

    # Define possible moves (up, down, left, right)
    possible_moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    for move in possible_moves:
        new_row, new_col = row + move[0], col + move[1]
        if 0 <= new_row < 3 and 0 <= new_col < 3:
            new_matrix = [list(row) for row in matrix]
            new_matrix[row][col], new_matrix[new_row][new_col] = new_matrix[new_row][new_col], new_matrix[row][col]
            moves.append(tuple(tuple(row) for row in new_matrix))

    return moves

def dfs(start_state, goal_state, depth, path, visited):
    """Perform Depth-Limited Search (DFS) to find a solution path within a given depth."""
    if start_state == goal_state:
        return path

    if depth <= 0:
        return None

    for move in get_moves(start_state):
        if move not in visited:
            visited.add(move)
            new_path = dfs(move, goal_state, depth - 1, path + [move], visited)
            if new_path:
                return new_path
            visited.remove(move)

    return None

def iddfs(start_state, goal_state):
    """Perform Iterative Deepening Depth-First Search (IDDFS) to find the shortest solution path."""
    depth = 0
    while True:
        visited = set()
        visited.add(start_state)
        solution_path = dfs(start_state, goal_state, depth, [start_state], visited)
        if solution_path:
            return solution_path
        depth += 1

def main():
    """Main function to take input and execute the IDDFS algorithm."""
    start_state = input("Enter start State: ")
    goal_state = input("Enter goal State: ")
    start_tuple = state_to_tuple(start_state)
    goal_tuple = state_to_tuple(goal_state)
    print("-----------------")
    print("IDDFS Algorithm")
    print("-----------------")
    start_time = time.time()
    solution_path = iddfs(start_tuple, goal_tuple)
    end_time = time.time()

    if solution_path:
        print("Time taken:", end_time - start_time, "seconds")
        print("Path Cost:", len(solution_path) - 1)
        print("No of Nodes Visited:", len(solution_path))
        for state in solution_path:
            for row in state:
                print(' '.join(map(str, row)))
            print("-----")
    else:
        print("No solution found.")

if __name__ == "__main__":
    main()

from collections import deque

class Graph:
    def __init__(self, adjacency_list):
        """Initializes the graph with an adjacency list."""
        self.adjacency_list = adjacency_list

    def get_neighbors(self, v):
        """Returns the neighbors of a given node."""
        return self.adjacency_list[v]

    def h(self, n):
        """Heuristic function: estimates the cost from node n to the goal."""
        H = {
            'The': 4,
            'cat': 3,
            'dog': 3,
            'runs': 2,
            'fast': 1
        }
        return H[n]

    def a_star_algorithm(self, start_node, stop_node):
        """Implements the A* search algorithm to find the optimal path."""
        open_list = set([start_node])
        closed_list = set([])

        g = {}  # Cost from start node to all other nodes
        g[start_node] = 0

        parents = {}  # Keeps track of paths
        parents[start_node] = start_node

        while len(open_list) > 0:
            n = None

            # Find the node with the lowest f(n) = g(n) + h(n)
            for v in open_list:
                if n is None or g[v] + self.h(v) < g[n] + self.h(n):
                    n = v

            if n is None:
                print("Path does not exist!")
                return None

            # If goal node is found, reconstruct and return the path
            if n == stop_node:
                reconst_path = []

                while parents[n] != n:
                    reconst_path.append(n)
                    n = parents[n]

                reconst_path.append(start_node)
                reconst_path.reverse()

                total_cost = g[stop_node]
                print(f"Sentence: {' '.join(reconst_path)}")
                print(f"Total cost: {total_cost}")
                return reconst_path

            # Explore all neighbors of the current node
            for (m, weight) in self.get_neighbors(n):
                if m not in open_list and m not in closed_list:
                    open_list.add(m)
                    parents[m] = n
                    g[m] = g[n] + weight
                else:
                    if g[m] > g[n] + weight:
                        g[m] = g[n] + weight
                        parents[m] = n

                        if m in closed_list:
                            closed_list.remove(m)
                            open_list.add(m)

            open_list.remove(n)
            closed_list.add(n)

        print("Path does not exist!")
        return None

# Define the graph given in adjacency list
adjacency_list = {
    'The': [('cat', 4), ('dog', 1)],
    'cat': [('runs', 1)],
    'dog': [('runs', 1)],
    'runs': [('fast', 5)]
}

graph1 = Graph(adjacency_list)
graph1.a_star_algorithm('The', 'fast')